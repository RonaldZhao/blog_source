# Python面试题

## Q：python这么好，说说它的特性吧

A：

1. python是解释型语言。即：它不需要编译，变运行便捷式；
2. python是动态类型化的。即：当声明变量的时候，无需指定变量的类型；
3. python非常适合面向对象编程。即：它允许定义类以及组合和继承；
4. python没有访问修饰符；
5. python中函数是一等对象(第一类对象)。即：函数可以在运行时动态创建；函数可以赋值给变量；函数可以作为参数传递给函数；函数可以作为返回值从函数返回；
6. python容易上手，编码效率高，但比编译型语言运行速度慢。幸运的是，python允许包含基于C的扩展，所以瓶颈可以被优化掉。

## Q： python中对象的赋值、浅拷贝、深拷贝的区别

A：

1. 对象的赋值

python中对象的赋值实际上是简单的对象的引用。即：当创建一个对象并将其赋值给一个变量的时候，python并没有拷贝这个对象，只是简单的把这个对象的引用赋值给变量。

```python
>>> list1 = [1,2,3,4]
>>> list2 = list1
>>> print(list1, id(list1))
[1, 2, 3, 4] 4552843656
>>> print(list2, id(list2))
[1, 2, 3, 4] 4552843656
>>> list1.append(5)
>>> print(list1, id(list1))
[1, 2, 3, 4, 5] 4552843656
>>> print(list2, id(list2))
[1, 2, 3, 4, 5] 4552843656
```

2. 浅拷贝

一般使用`copy.copy()`可以进行对象的浅拷贝。但对于对象中的元素，它仍然使用原始的引用。

```python
>>> import copy
>>> list1 = [1,2,3,4, [5,6,7,8]]
>>> print(list1, id(list1))
[1, 2, 3, 4, [5, 6, 7, 8]] 4322790536
>>> list2 = copy.copy(list1)
>>> print(list2, id(list2))
1, 2, 3, 4, [5, 6, 7, 8]] 4322790792
>>> list1.append(9)
>>> print(list1, id(list1))
[1, 2, 3, 4, [5, 6, 7, 8], 9] 4322790536
>>> print(list2, id(list2))
1, 2, 3, 4, [5, 6, 7, 8]] 4322790792
>>> list1[4].append(10)
>>> print(list1, id(list1))
[1, 2, 3, 4, [5, 6, 7, 8, 10], 9] 4322790536
>>> print(list2, id(list2))
[1, 2, 3, 4, [5, 6, 7, 8, 10]] 4322790792
```

使用`copy.copy()`对`list1`浅拷贝到`list2`，`list2`复制了`list1`的对象，但是`list2`里面的`[5,6,7,8]`和`list1`里面的`[5,6,7,8]`其实都是指向**同一块内存地址**，所以改变了`list1[4]`后`list2[4]`也会发生改变。

3. 深拷贝

深拷贝需要使用`copy.deepcopy()`函数。它会复制一个容器对象，以及它里面的所有元素(包含元素的子元素，即递归复制)。

当对`list1`列表进行深拷贝之后，`list2`复制了`list1`对象，但是与浅拷贝不同的是，`list2`里面的`[5,6,7,8]`与`list1`里面的`[5,6,7,8]`是指向**不同的内存地址**。

## Q：python中 == 和 is 的区别

A：

`is`判断对象标识符是否一致，而`==`是判断两个对象的内容是否相等。`x is y`相当于`id(x) == id(y)`；`==`会调用对象内部的`__eq__()`检查两个对象的内容是否相等。

## Q：如何在python中实现多线程

A：

python中有一个多线程包`threading`可以用来实现多线程。但同时Python中有一个`GIL(Global Interpreter Lock，全局解释器锁)`，它确保在任何时刻只有一个线程可以执行。

线程获取`GIL`，做一些工作，然后将`GIL`传递到下一个线程。这种情况发生的非常快，所以对于人眼而言，它可能看起来像所有线程并行执行，但它们实际上只是轮流使用相同的CPU内核。因此GIL的存在使得Python中的多线程无法真正的利用多核的优势来提高性能。

对于IO密集型操作，在等待操作系统返回的时候会释放GIL。比如爬虫因为有等待服务器的响应时间，可以利用多线程来加速；但是对于CPU密集型操作，只能通过多进程`multiprocess`来加速。

## Q：Python中的猴子补丁是什么

A：

猴子补丁，是一种非常Pythonic的用法。即函数在Python中可以像使用变量一样对它们进行赋值等操作，我们可以在运行时替换模块，这种手法俗称`猴子补丁`。

## Q：Python中的 __new__ 和 __init__ 的区别

A：

`__init__`为初始化方法，而`__new__`方法才是真正的构造函数。只有继承了`object`的类才有`__new__`。

`__new__`至少要有一个参数`cls`，代表要实例化的类，此参数在实例化时由Python解释器自动提供。`__new__`必须要有返回值，返回实例化出来的实例。

`__init__`有一个参数`self`，就是这个`__new__`返回的实例。先运行`__new__`然后才运行`__init__`。

`__init__`在`__new__`的基础上可以完成一些其他初始化的动作。`__init__`不需要返回值。

## 笔记整理出处

[精心整理的8道Python面试题，你答不答的出来](https://juejin.im/post/5abd9f9ef265da239d496874)